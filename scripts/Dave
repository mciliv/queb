#!/usr/bin/env node

// Dave - Universal Development Assistant
// Handles all operations for the molecular visualization project

const { spawn } = require('child_process');
const path = require('path');
const fs = require('fs');

// Available operations
const operations = {
  'dev': 'Start development server',
  'build': 'Build frontend',
  'test': 'Run tests',
  'clean': 'Clean up ports and processes',
  'status': 'Check server status',
  'help': 'Show this help'
};

function showHelp() {
  console.log('üß¨ Dave - Molecular Visualization Assistant\n');
  console.log('Usage: Dave [operation]\n');
  console.log('Available operations:');
  Object.entries(operations).forEach(([op, desc]) => {
    console.log(`  ${op.padEnd(10)} - ${desc}`);
  });
  console.log('\nExamples:');
  console.log('  Dave dev     # Start development server');
  console.log('  Dave test    # Run tests');
  console.log('  Dave clean   # Clean up ports');
}

function findProjectRoot() {
  let currentDir = process.cwd();
  const maxDepth = 10;

  for (let i = 0; i < maxDepth; i++) {
    if (fs.existsSync(path.join(currentDir, 'package.json'))) {
      return currentDir;
    }
    const parentDir = path.dirname(currentDir);
    if (parentDir === currentDir) break;
    currentDir = parentDir;
  }

  return process.cwd();
}

async function runDev() {
  console.log('üöÄ Starting development server...');
  const projectRoot = findProjectRoot();
  const devScript = path.join('/Users/m/web', 'dev');
  
  const child = spawn('node', [devScript], {
    stdio: 'inherit',
    cwd: projectRoot
  });

  child.on('exit', (code) => {
    process.exit(code);
  });

  child.on('error', (error) => {
    console.error('‚ùå Failed to start dev server:', error.message);
    process.exit(1);
  });
}

async function runBuild() {
  console.log('üî® Building frontend...');
  const projectRoot = findProjectRoot();
  const buildScript = path.join(projectRoot, 'frontend', 'build-frontend.js');
  
  const child = spawn('node', [buildScript], {
    stdio: 'inherit',
    cwd: projectRoot
  });

  return new Promise((resolve, reject) => {
    child.on('close', (code) => {
      if (code === 0) {
        console.log('‚úÖ Build completed');
        resolve();
      } else {
        reject(new Error(`Build failed with code ${code}`));
      }
    });
  });
}

async function runTest() {
  console.log('üß™ Running tests...');
  const projectRoot = findProjectRoot();
  
  const child = spawn('npm', ['run', 'test:quick'], {
    stdio: 'inherit',
    cwd: projectRoot
  });

  return new Promise((resolve, reject) => {
    child.on('close', (code) => {
      if (code === 0) {
        console.log('‚úÖ Tests passed');
        resolve();
      } else {
        reject(new Error(`Tests failed with code ${code}`));
      }
    });
  });
}

async function cleanPorts() {
  console.log('üßπ Cleaning up ports...');
  const net = require('net');
  const { execSync } = require('child_process');

  const portsToCheck = [3001, 3002, 3003, 3004, 3005];

  for (const port of portsToCheck) {
    try {
      const server = net.createServer();
      const isPortFree = new Promise((resolve) => {
        server.listen(port, '127.0.0.1', () => {
          server.close();
          resolve(true);
        });
        server.on('error', () => resolve(false));
      });

      const free = await isPortFree;
      if (!free) {
        console.log(`‚ö†Ô∏è Port ${port} is in use, cleaning up...`);
        try {
          execSync(`lsof -ti:${port} | xargs kill -9 2>/dev/null || true`);
          console.log(`‚úÖ Cleaned up port ${port}`);
        } catch (e) {
          console.log(`‚ö†Ô∏è Could not cleanup port ${port}: ${e.message}`);
        }
      }
    } catch (e) {
      // Ignore cleanup errors
    }
  }
  console.log('‚úÖ Port cleanup completed');
}

async function checkStatus() {
  console.log('üìä Checking server status...');
  const net = require('net');
  const portsToCheck = [3001, 3002, 3003, 3004, 3005];

  for (const port of portsToCheck) {
    try {
      const server = net.createServer();
      const isPortFree = new Promise((resolve) => {
        server.listen(port, '127.0.0.1', () => {
          server.close();
          resolve(true);
        });
        server.on('error', () => resolve(false));
      });

      const free = await isPortFree;
      if (!free) {
        console.log(`üü¢ Port ${port} is in use`);
      } else {
        console.log(`‚ö™ Port ${port} is free`);
      }
    } catch (e) {
      console.log(`‚ùå Error checking port ${port}: ${e.message}`);
    }
  }
}

async function main() {
  const operation = process.argv[2] || 'dev';

  switch (operation) {
    case 'dev':
      await runDev();
      break;
    case 'build':
      await runBuild();
      break;
    case 'test':
      await runTest();
      break;
    case 'clean':
      await cleanPorts();
      break;
    case 'status':
      await checkStatus();
      break;
    case 'help':
      showHelp();
      break;
    default:
      console.log(`‚ùå Unknown operation: ${operation}`);
      showHelp();
      process.exit(1);
  }
}

main().catch((error) => {
  console.error('‚ùå Fatal error:', error);
  process.exit(1);
});
