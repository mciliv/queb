#!/usr/bin/env node

// Aggressively suppress debugger output immediately
process.env.NODE_OPTIONS = '';
process.env.NODE_INSPECT = '0';
process.env.NODE_INSPECT_RESUME_ON_START = '0';
process.env.VSCODE_INSPECTOR_OPTIONS = '';
delete process.env.NODE_OPTIONS;
delete process.env.NODE_INSPECT;
delete process.env.NODE_INSPECT_RESUME_ON_START;
delete process.env.VSCODE_INSPECTOR_OPTIONS;

const { spawn, execSync } = require('child_process');
const path = require('path');
const fs = require('fs');
const net = require('net');
const readline = require('readline');

// Import required modules for comprehensive validation
let Client, request;
try {
  const pg = require('pg');
  Client = pg.Client;
} catch (error) {
  // pg module not available - database operations will show error
}

try {
  request = require('supertest');
} catch (error) {
  // supertest not available - API testing will be limited
}

// Global fetch polyfill for Node.js environments
if (typeof fetch === 'undefined') {
  try {
    global.fetch = require('node-fetch');
  } catch (error) {
    // node-fetch not available - some tests will be limited
  }
}

// ========================================
// UTILITY FUNCTIONS (from converted scripts)
// ========================================

// Colored logging utilities
const log = {
  info: (msg) => console.log(`\x1b[32m‚úÖ ${msg}\x1b[0m`),
  warn: (msg) => console.log(`\x1b[33m‚ö†Ô∏è  ${msg}\x1b[0m`),
  error: (msg) => console.log(`\x1b[31m‚ùå ${msg}\x1b[0m`)
};

// Port checking utility
async function checkPort(port) {
  return new Promise((resolve) => {
    const server = net.createServer();
    server.listen(port, '127.0.0.1', () => {
      server.close();
      resolve(false); // Port is free
    });
    server.on('error', () => resolve(true)); // Port is in use
  });
}

// URL checking utility
async function checkUrl(url, timeout = 5000) {
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    const response = await fetch(url, { 
      signal: controller.signal,
      method: 'HEAD'
    });
    
    clearTimeout(timeoutId);
    return response.ok;
  } catch (error) {
    return false;
  }
}

// Database configuration
const getDbConfig = () => ({
  host: process.env.DB_HOST || 'localhost',
  port: process.env.DB_PORT || 5432,
  database: process.env.DB_NAME || 'mol_users',
  user: process.env.DB_USER || 'mol_user',
  password: process.env.DB_PASSWORD
});

// Ask user confirmation
async function askConfirmation(question) {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });

  return new Promise((resolve) => {
    rl.question(question, (answer) => {
      rl.close();
      resolve(answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes');
    });
  });
}

// ========================================
// COMPREHENSIVE APP VALIDATION RULES
// ========================================

const APP_VALIDATION_RULES = {
  // Core Application Requirements
  core: {
    server: {
      startup: { maxTime: 5000, healthEndpoints: ['/'] },
      apis: {
        '/analyze-text': { method: 'POST', requiredFields: ['object'], timeout: 15000 },
        '/image-molecules': { method: 'POST', requiredFields: ['imageBase64'], timeout: 20000 },
        '/generate-sdfs': { method: 'POST', requiredFields: ['smiles'], timeout: 5000 },
        '/validate-payment': { method: 'POST', requiredFields: ['device_token'], timeout: 3000 }
      },
      performance: { maxResponseTime: 2000, maxMemoryUsage: 1073741824 }
    },
    
    frontend: {
      components: {
        textInput: ['#object-input', '.validation-message'],
        camera: ['#video-feed', '#capture-btn', '.camera-status'],
        payment: ['.payment-setup', '.account-status'],
        molecular: ['.viewer-container', '.molecules-display']
      },
      performance: { maxLoadTime: 3000, maxInteractionLatency: 100 },
      accessibility: { keyboardNav: true, ariaLabels: true, focusManagement: true }
    },
    
    database: {
      optional: true,
      fallback: { fileSystem: true, gracefulDegradation: true },
      operations: { maxLatency: 1000, backupStrategy: true }
    }
  },

  // Input Validation and Data Integrity
  validation: {
    textInput: {
      minLength: 2,
      maxLength: 500,
      invalidPatterns: [
        /^(love|hate|happy|sad|angry|joy|fear|hope|dream|idea|thought|feeling|emotion)/,
        /^(running|walking|talking|thinking|sleeping|eating|drinking)$/,
        /^[a-z]{1,2}$/,
        /^[^a-z]*$/,
        /^(asdf|qwerty|test|random|nothing|something|anything|everything)$/i,
        /^(blah|meh|hmm|ugh|oof|nah|yeah|yep|nope|ok|okay)$/i,
        /^(spam|fake|scam|bot|robot|ai|gpt)$/i
      ],
      validExamples: ['water', 'ethanol', 'coffee', 'apple', 'salt', 'sugar', 'olive oil']
    },
    
    imageInput: {
      supportedFormats: ['jpeg', 'jpg', 'png', 'webp'],
      maxSize: 10485760, // 10MB
      minSize: 1024, // 1KB
      dimensions: { min: { width: 50, height: 50 }, max: { width: 4096, height: 4096 } }
    },
    
    molecularData: {
      smilesFormat: /^[A-Za-z0-9@+\-\[\]()=#$\.]+$/,
      maxSmilesLength: 1000,
      requiredFields: ['name', 'smiles'],
      optionalFields: ['formula', 'mass', 'properties']
    }
  },

  // Security and Privacy
  security: {
    dataHandling: {
      inputSanitization: true,
      outputEscaping: true,
      xssProtection: true,
      sqlInjectionProtection: true
    },
    
    apiSecurity: {
      rateLimit: { enabled: true, maxRequests: 100, timeWindow: 60000 },
      authentication: { tokenValidation: true, sessionManagement: true },
      encryption: { inTransit: true, sensitiveData: true }
    }
  },

  // Performance and Reliability
  performance: {
    benchmarks: {
      pageLoad: { maxTime: 3000, criticalResources: ['bundle.js', 'style.css'] },
      apiResponse: { maxTime: 15000, averageTime: 5000 },
      imageProcessing: { maxTime: 20000, memoryEfficient: true },
      molecularRendering: { maxTime: 5000, interactive: true }
    },
    
    reliability: {
      errorHandling: { gracefulDegradation: true, userNotification: true },
      networkResilience: { retryLogic: true, timeoutHandling: true },
      memoryManagement: { noLeaks: true, efficientCleanup: true },
      concurrency: { threadSafe: true, sessionIsolation: true }
    }
  }
};

// Validation Helper Functions
const ValidationHelpers = {
  // Check if input matches validation rules
  validateTextInput: (text) => {
    if (!text || !text.trim()) return 'Empty input not allowed';
    
    const trimmed = text.trim();
    const rules = APP_VALIDATION_RULES.validation.textInput;
    
    if (trimmed.length < rules.minLength) return `Input too short (min ${rules.minLength})`;
    if (trimmed.length > rules.maxLength) return `Input too long (max ${rules.maxLength})`;
    
    for (const pattern of rules.invalidPatterns) {
      if (pattern.test(trimmed.toLowerCase())) {
        return 'Invalid input pattern detected';
      }
    }
    
    return null; // Valid
  },
  
  // Check if API response matches expected format
  validateApiResponse: (response, endpoint) => {
    const endpointRules = APP_VALIDATION_RULES.core.server.apis[endpoint];
    if (!endpointRules) return false;
    
    // Check response structure
    if (response.error && !response.data) return true; // Error response is valid
    if (response.data && !response.error) return true; // Success response is valid
    
    return false; // Invalid response structure
  },
  
  // Check if security requirements are met
  validateSecurity: (context, data) => {
    // Basic input sanitization check
    if (context === 'input' && typeof data === 'string') {
      return !/<script|javascript:|on\w+=/i.test(data);
    }
    
    return true; // Default to secure
  }
};

const operations = {
  'dev': 'Deploy to dev.queb.space (default)',
  'prod': 'Deploy to queb.space (production)',
  'build': 'Build frontend only',
  'test': 'Run tests',
  'validate': 'Run comprehensive app validation',
  'health': 'Check complete app health',
  'auto': 'Auto-validate and run app if healthy',
  'start': 'Start local development server',
  'clean': 'Clean up ports and processes',
  'status': 'Check server status',
  'env': 'Check environment status',
  'db-health': 'Check database health',
  'db-backup': 'Create database backup',
  'db-restore': 'Restore database from backup',
  'db-setup': 'Set up database for first time',
  'setup-domains': 'Set up dev.queb.space and queb.space domains',
  'setup-aliases': 'Output shell aliases for sourcing',
  'help': 'Show this help'
};

// Determine project directory (look for package.json or index.js)
function findProjectRoot(startDir) {
  // For flattened repo, the project root is one level up from scripts/
  const scriptDir = __dirname;
  const projectRoot = path.dirname(scriptDir);
  
  // Verify this is correct by checking for package.json
  if (fs.existsSync(path.join(projectRoot, 'package.json'))) {
    return projectRoot;
  }
  
  // Fallback to original logic if needed
  let currentDir = startDir;
  const maxDepth = 10;

  for (let i = 0; i < maxDepth; i++) {
    if (fs.existsSync(path.join(currentDir, 'package.json')) ||
        fs.existsSync(path.join(currentDir, 'index.js'))) {
      return currentDir;
    }
    const parentDir = path.dirname(currentDir);
    if (parentDir === currentDir) break; // Reached root
    currentDir = parentDir;
  }

  return projectRoot; // Use calculated project root
}

// Load project configuration
// Returns config object from PROJECT_ROOT/config/project.js or null if not found
function loadProjectConfig(projectRoot) {
  const configPath = path.join(projectRoot, 'config', 'project.js');

  if (fs.existsSync(configPath)) {
    return require(configPath);
  }

  return null;
}

function showHelp() {
  console.log('üß¨ Universal Development Assistant with App Validation\n');
  console.log('Usage: d [operation]\n');
  console.log('Available operations:');
  Object.entries(operations).forEach(([op, desc]) => {
    console.log(`  ${op.padEnd(15)} - ${desc}`);
  });
  console.log('\nValidation & Health:');
  console.log('  validate        - Run comprehensive input, security, and performance validation');
  console.log('  health          - Check complete app health (server, APIs, frontend, security)');
  console.log('\nExamples:');
  console.log('  d auto          # üöÄ Auto-validate and start app (RECOMMENDED)');
  console.log('  d start         # Start local development server');
  console.log('  d validate      # Run comprehensive app validation');
  console.log('  d health        # Check complete app health');
  console.log('  d dev           # Deploy to development (dev.queb.space)');
  console.log('  d prod          # Deploy to production (queb.space)');
  console.log('  d test          # Run tests');
  console.log('  d clean         # Clean up ports and processes');
  console.log('\nüöÄ Auto-Run Workflow (d auto):');
  console.log('  1. Clean up existing processes');
  console.log('  2. Run comprehensive validation (must pass 80%)');
  console.log('  3. Perform health check on all systems');
  console.log('  4. Build frontend automatically');
  console.log('  5. Start development server');
  console.log('  6. Auto-open browser to app');
  console.log('\nüîç Validation Features:');
  console.log('  ‚Ä¢ Input validation (15+ invalid patterns, length limits)');
  console.log('  ‚Ä¢ Security validation (XSS detection, input sanitization)');
  console.log('  ‚Ä¢ Performance benchmarks (response times, loading speeds)');
  console.log('  ‚Ä¢ File structure validation (critical files check)');
  console.log('  ‚Ä¢ API endpoint validation (server response validation)');
  console.log('  ‚Ä¢ Dependency validation (required packages check)');
}

// Process and port cleanup utility (aggressive mode)
async function cleanupProcesses(projectRoot, aggressive = false) {
  const { execSync } = require('child_process');
  const net = require("net");

  if (aggressive) {
    console.log('üßπ Cleaning up previous processes...');
  }

  // Define ports to check and clean
  const portsToCheck = [8080, 3001, 3002, 3003, 3004, 3005];

  // Check and kill processes using our ports
  for (const port of portsToCheck) {
    try {
      const isPortFree = await new Promise((resolve) => {
        const server = net.createServer();
        server.listen(port, "127.0.0.1", () => {
          server.close();
          resolve(true);
        });
        server.on("error", () => resolve(false));
      });

      if (!isPortFree) {
        if (aggressive) {
          console.log(`‚ö†Ô∏è Port ${port} is in use, cleaning up...`);
        }
        // Try to find and kill the process quietly
        try {
          const pidOutput = execSync(`lsof -ti:${port}`, { encoding: 'utf8' }).trim();
          if (pidOutput) {
            const pids = pidOutput.split('\n');
            for (const pid of pids) {
              if (pid.trim()) {
                try {
                  process.kill(parseInt(pid), 'SIGTERM');
                  if (aggressive) {
                    console.log(`‚úÖ Killed process ${pid} on port ${port}`);
                  }
                  // Wait for process to terminate
                  await new Promise(resolve => setTimeout(resolve, 2000));
                } catch (killError) {
                  // Silent failure
                }
              }
            }
          }
        } catch (findError) {
          // Silent failure
        }
      }
    } catch (e) {
      if (aggressive) {
        console.log(`‚ö†Ô∏è Port ${port} check failed: ${e.message}`);
      }
    }
  }

  // Additional cleanup: kill any node processes running our scripts
  if (aggressive) {
    try {
      const nodeProcesses = execSync(`pgrep -f "node.*${path.basename(projectRoot)}" || true`, { encoding: 'utf8' }).trim();
      if (nodeProcesses) {
        const pids = nodeProcesses.split('\n');
        for (const pid of pids) {
          if (pid.trim()) {
            try {
              process.kill(parseInt(pid), 'SIGTERM');
              console.log(`‚úÖ Killed node process ${pid}`);
            } catch (killError) {
              // Ignore if process is already dead
            }
          }
        }
      }
    } catch (e) {
      // Ignore pgrep errors
    }

    // Kill test-related Chrome processes only
    try {
      execSync('pkill -f "chrome.*--remote-debugging-port" || true', { stdio: 'ignore' });
      execSync('pkill -f "puppeteer" || true', { stdio: 'ignore' });
      if (aggressive) {
        console.log('‚úÖ Cleaned up Chrome debugging processes');
      }
    } catch (e) {
      // Ignore cleanup errors
    }

    // Clean up log files and temp files
    try {
      const logsDir = path.join(projectRoot, 'logs');
      if (fs.existsSync(logsDir)) {
        const files = fs.readdirSync(logsDir);
        let cleanedCount = 0;
        for (const file of files) {
          if (file.endsWith('.log') && files.length > 5) { // Keep last 5 log files
            fs.unlinkSync(path.join(logsDir, file));
            cleanedCount++;
          }
        }
        if (cleanedCount > 0) {
          console.log(`üßπ Cleaned up ${cleanedCount} old log files`);
        }
      }
    } catch (e) {
      // Ignore cleanup errors
    }
  }

  if (aggressive) {
    console.log('‚úÖ Process cleanup completed');
  }
}

async function runBuild(projectRoot) {
  console.log('üî® Building frontend...');
  const buildScript = path.join(projectRoot, 'src', 'client', 'build-frontend.js');

  const child = spawn('node', [buildScript], {
    stdio: 'inherit',
    cwd: projectRoot
  });

  return new Promise((resolve, reject) => {
    child.on('close', (code) => {
      if (code === 0) {
        console.log('‚úÖ Build completed');
        resolve();
      } else {
        reject(new Error(`Build failed with code ${code}`));
      }
    });
  });
}

async function runTest(projectRoot) {
  console.log('üß™ Running tests...');

  const child = spawn('npm', ['run', 'test:quick'], {
    stdio: 'inherit',
    cwd: projectRoot
  });

  return new Promise((resolve, reject) => {
    child.on('close', (code) => {
      if (code === 0) {
        console.log('‚úÖ Tests passed');
        resolve();
      } else {
        reject(new Error(`Tests failed with code ${code}`));
      }
    });
  });
}

// ========================================
// COMPREHENSIVE APP VALIDATION FUNCTIONS
// ========================================

async function runAppValidation(projectRoot) {
  console.log('üîç Running comprehensive app validation...');
  const startTime = Date.now();
  const validationReport = {
    inputValidation: false,
    security: false,
    performance: false,
    fileStructure: false,
    dependencies: false
  };

  try {
    // 1. Input Validation Tests
    console.log('\nüìù Testing input validation rules...');
    const validInputs = APP_VALIDATION_RULES.validation.textInput.validExamples;
    let validInputsPassed = 0;
    
    validInputs.forEach(example => {
      const result = ValidationHelpers.validateTextInput(example);
      if (result === null) {
        validInputsPassed++;
      }
    });
    
    if (validInputsPassed === validInputs.length) {
      validationReport.inputValidation = true;
      log.info(`Input validation: ${validInputsPassed}/${validInputs.length} valid examples passed`);
    } else {
      log.error(`Input validation: Only ${validInputsPassed}/${validInputs.length} valid examples passed`);
    }

    // 2. Security Validation Tests
    console.log('\nüîí Testing security validation...');
    const maliciousInputs = [
      '<script>alert("xss")</script>',
      'javascript:alert(1)',
      '<img onerror="alert(1)" src="x">'
    ];
    
    let securityTestsPassed = 0;
    maliciousInputs.forEach(maliciousInput => {
      const isSecure = ValidationHelpers.validateSecurity('input', maliciousInput);
      if (!isSecure) {
        securityTestsPassed++;
      }
    });
    
    if (securityTestsPassed === maliciousInputs.length) {
      validationReport.security = true;
      log.info(`Security validation: ${securityTestsPassed}/${maliciousInputs.length} threats detected`);
    } else {
      log.error(`Security validation: Only ${securityTestsPassed}/${maliciousInputs.length} threats detected`);
    }

    // 3. Performance Benchmarks
    console.log('\n‚ö° Validating performance benchmarks...');
    const benchmarks = APP_VALIDATION_RULES.performance.benchmarks;
    let benchmarksPassed = 0;
    
    Object.keys(benchmarks).forEach(operation => {
      const benchmark = benchmarks[operation];
      if (benchmark.maxTime > 1000 && benchmark.maxTime < 30000) {
        benchmarksPassed++;
      }
    });
    
    if (benchmarksPassed === Object.keys(benchmarks).length) {
      validationReport.performance = true;
      log.info(`Performance benchmarks: ${benchmarksPassed}/${Object.keys(benchmarks).length} are realistic`);
    }

    // 4. File Structure Validation
    console.log('\nüìÅ Validating file structure...');
    const criticalFiles = [
      'src/server/api/server.js',
      'src/client/core/App.jsx',
      'src/client/core/index.html',
      'package.json'
    ];
    
    let filesExist = 0;
    criticalFiles.forEach(file => {
      const filePath = path.join(projectRoot, file);
      if (fs.existsSync(filePath)) {
        const stats = fs.statSync(filePath);
        if (stats.size > 0) {
          filesExist++;
        }
      }
    });
    
    if (filesExist === criticalFiles.length) {
      validationReport.fileStructure = true;
      log.info(`File structure: ${filesExist}/${criticalFiles.length} critical files present`);
    } else {
      log.error(`File structure: Only ${filesExist}/${criticalFiles.length} critical files present`);
    }

    // 5. Dependencies Validation
    console.log('\nüì¶ Validating dependencies...');
    const packageJsonPath = path.join(projectRoot, 'package.json');
    if (fs.existsSync(packageJsonPath)) {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      const requiredDeps = ['express', 'cors', 'zod'];
      let depsPresent = 0;
      
      requiredDeps.forEach(dep => {
        if (packageJson.dependencies && packageJson.dependencies[dep]) {
          depsPresent++;
        }
      });
      
      if (depsPresent === requiredDeps.length) {
        validationReport.dependencies = true;
        log.info(`Dependencies: ${depsPresent}/${requiredDeps.length} required packages present`);
      } else {
        log.error(`Dependencies: Only ${depsPresent}/${requiredDeps.length} required packages present`);
      }
    }

    // Summary
    const duration = Date.now() - startTime;
    const passedChecks = Object.values(validationReport).filter(check => check).length;
    const totalChecks = Object.keys(validationReport).length;
    const validationPercentage = (passedChecks / totalChecks) * 100;

    console.log('\nüìä Validation Summary:');
    console.log(`   Overall Score: ${validationPercentage.toFixed(1)}% (${passedChecks}/${totalChecks} checks passed)`);
    console.log(`   Duration: ${duration}ms`);
    
    Object.keys(validationReport).forEach(check => {
      const status = validationReport[check] ? '‚úÖ' : '‚ùå';
      console.log(`   ${status} ${check.charAt(0).toUpperCase() + check.slice(1)}`);
    });

    if (validationPercentage >= 80) {
      log.info('App validation passed!');
    } else {
      log.error(`App validation failed (${validationPercentage.toFixed(1)}% < 80%)`);
    }

    return validationReport;
  } catch (error) {
    log.error(`Validation failed: ${error.message}`);
    throw error;
  }
}

async function runAppHealthCheck(projectRoot) {
  console.log('üè• Running comprehensive app health check...');
  const startTime = Date.now();
  const healthReport = {
    server: false,
    frontend: false,
    apis: false,
    validation: false,
    security: false,
    performance: false
  };

  try {
    // Try to load the server
    let app;
    try {
      app = require(path.join(projectRoot, 'src/server/api/server'));
      if (app) {
        healthReport.server = true;
        log.info('Server: Available and functional');
      }
    } catch (error) {
      log.warn(`Server: Not available (${error.message})`);
    }

    // Check frontend components
    const frontendComponents = APP_VALIDATION_RULES.core.frontend.components;
    let frontendComponentCount = 0;
    
    Object.keys(frontendComponents).forEach(component => {
      const elements = frontendComponents[component];
      if (Array.isArray(elements)) {
        frontendComponentCount += elements.length;
      }
    });
    
    if (frontendComponentCount > 0) {
      healthReport.frontend = true;
      log.info(`Frontend: ${frontendComponentCount} components defined`);
    }

    // Test API endpoints if server is available
    if (app && typeof fetch !== 'undefined') {
      const request = require('supertest');
      const apis = APP_VALIDATION_RULES.core.server.apis;
      let apiTestsPassed = 0;
      
      for (const endpoint of Object.keys(apis)) {
        try {
          const response = await request(app).post(endpoint).send({});
          
          // Expecting error responses for empty data
          if ([400, 500].includes(response.status)) {
            apiTestsPassed++;
          }
        } catch (error) {
          // API not responding - expected in some cases
        }
      }
      
      if (apiTestsPassed >= Object.keys(apis).length / 2) {
        healthReport.apis = true;
        log.info(`APIs: ${apiTestsPassed}/${Object.keys(apis).length} endpoints responding`);
      } else {
        log.warn(`APIs: Only ${apiTestsPassed}/${Object.keys(apis).length} endpoints responding`);
      }
    } else {
      log.warn('APIs: Cannot test (server not available or missing dependencies)');
    }

    // Validation system check
    const validationTests = APP_VALIDATION_RULES.validation.textInput.validExamples;
    let validationTestsPassed = 0;
    
    validationTests.forEach(example => {
      const result = ValidationHelpers.validateTextInput(example);
      if (result === null) {
        validationTestsPassed++;
      }
    });
    
    if (validationTestsPassed === validationTests.length) {
      healthReport.validation = true;
      log.info(`Validation: ${validationTestsPassed}/${validationTests.length} tests passed`);
    }

    // Security check
    const securityTests = [
      '<script>alert("test")</script>',
      'javascript:void(0)',
      '<img onerror="alert(1)" src="x">'
    ];
    
    let securityTestsPassed = 0;
    securityTests.forEach(maliciousInput => {
      const isSecure = ValidationHelpers.validateSecurity('input', maliciousInput);
      if (!isSecure) {
        securityTestsPassed++;
      }
    });
    
    if (securityTestsPassed === securityTests.length) {
      healthReport.security = true;
      log.info(`Security: ${securityTestsPassed}/${securityTests.length} threats detected`);
    }

    // Performance check
    const totalTime = Date.now() - startTime;
    const performanceThreshold = APP_VALIDATION_RULES.performance.benchmarks.pageLoad.maxTime;
    
    if (totalTime < performanceThreshold) {
      healthReport.performance = true;
      log.info(`Performance: Health check completed in ${totalTime}ms`);
    } else {
      log.warn(`Performance: Health check took ${totalTime}ms (threshold: ${performanceThreshold}ms)`);
    }

    // Overall Health Assessment
    const passedChecks = Object.values(healthReport).filter(check => check).length;
    const totalChecks = Object.keys(healthReport).length;
    const healthPercentage = (passedChecks / totalChecks) * 100;

    console.log('\nüìä Overall App Health Report:');
    console.log(`   Health Score: ${healthPercentage.toFixed(1)}% (${passedChecks}/${totalChecks} checks passed)`);
    console.log(`   Duration: ${Date.now() - startTime}ms`);
    
    console.log('\nüìã Detailed Status:');
    Object.keys(healthReport).forEach(check => {
      const status = healthReport[check] ? '‚úÖ' : '‚ùå';
      console.log(`   ${status} ${check.charAt(0).toUpperCase() + check.slice(1)}`);
    });

    if (healthPercentage >= 66.7) {
      log.info('App health check passed!');
    } else {
      log.error(`App health check failed (${healthPercentage.toFixed(1)}% < 66.7%)`);
    }

    return healthReport;
  } catch (error) {
    log.error(`Health check failed: ${error.message}`);
    throw error;
  }
}

// Auto-validate and run app
async function runAutoValidateAndStart(projectRoot) {
  console.log('üöÄ Auto-validating and starting app...\n');
  
  try {
    // Step 1: Clean up any existing processes
    console.log('üßπ Cleaning up existing processes...');
    await cleanupProcesses(projectRoot, true);
    
    // Step 2: Run comprehensive validation
    console.log('\nüìã Running comprehensive validation...');
    const validationReport = await runAppValidation(projectRoot);
    const validationScore = Object.values(validationReport).filter(check => check).length / Object.keys(validationReport).length * 100;
    
    if (validationScore < 80) {
      log.error(`Validation failed (${validationScore.toFixed(1)}% < 80%). Cannot start app safely.`);
      console.log('\nüí° Fix validation issues before running the app:');
      Object.keys(validationReport).forEach(check => {
        if (!validationReport[check]) {
          console.log(`   ‚ùå ${check.charAt(0).toUpperCase() + check.slice(1)} needs attention`);
        }
      });
      return false;
    }
    
    // Step 3: Run health check
    console.log('\nüè• Running health check...');
    const healthReport = await runAppHealthCheck(projectRoot);
    const healthScore = Object.values(healthReport).filter(check => check).length / Object.keys(healthReport).length * 100;
    
    // Step 4: Build frontend
    console.log('\nüî® Building frontend...');
    await runBuild(projectRoot);
    
    // Step 5: Start the development server
    console.log('\nüöÄ Starting development server...');
    console.log('üìä Validation Summary:');
    console.log(`   ‚úÖ Validation Score: ${validationScore.toFixed(1)}%`);
    console.log(`   ‚úÖ Health Score: ${healthScore.toFixed(1)}%`);
    console.log(`   ‚úÖ App is ready to run safely!\n`);
    
    // Start the local development server
    await runLocalDevServer(projectRoot);
    
  } catch (error) {
    log.error(`Auto-validation and start failed: ${error.message}`);
    console.log('\nüí° Try running individual commands:');
    console.log('   d validate  # Check what\'s failing');
    console.log('   d health    # Check app health');
    console.log('   d clean     # Clean up processes');
    console.log('   d start     # Start server manually');
    throw error;
  }
}

// Start local development server (simplified version of runDevServer)
async function runLocalDevServer(projectRoot) {
  const entryPoint = findEntryPoint(projectRoot);

  if (!entryPoint) {
    log.error('No entry point found');
    return false;
  }

  // Set development mode
  process.env.NODE_ENV = 'development';
  
  const port = process.env.PORT || 8080;
  const httpsPort = process.env.HTTPS_PORT || 3001;

  console.log(`üìÅ Project: ${path.basename(projectRoot)}`);
  console.log(`üåê Starting local server...`);
  console.log(`üì° HTTP:  http://localhost:${port}`);
  console.log(`üîê HTTPS: https://localhost:${httpsPort}`);
  console.log(`üì± Ready for development!\n`);

  // Start the server with clean output
  const child = spawn('node', ['--no-deprecation', entryPoint], {
    stdio: 'inherit',
    cwd: projectRoot,
    env: {
      ...process.env,
      NODE_OPTIONS: '',
      NODE_INSPECT_RESUME_ON_START: '0',
      NODE_INSPECT: '0'
    }
  });

  // Auto-open browser after a delay
  setTimeout(() => {
    const { exec } = require('child_process');
    const targetUrl = `http://localhost:${port}`;
    
    try {
      if (process.platform === 'darwin') {
        exec(`open -a "Google Chrome" "${targetUrl}" --args --incognito`, { stdio: 'ignore' });
      } else if (process.platform === 'win32') {
        exec(`start chrome "${targetUrl}" --incognito`, { shell: true, stdio: 'ignore' });
      } else {
        exec(`google-chrome "${targetUrl}" --incognito || xdg-open "${targetUrl}"`, { stdio: 'ignore' });
      }
      console.log('üåê Browser opened automatically');
    } catch (err) {
      console.log(`üí° Open your browser to: ${targetUrl}`);
    }
  }, 3000);

  // Handle process termination
  child.on('exit', (code) => {
    if (code === 0) {
      console.log('‚úÖ Server exited cleanly');
    } else {
      console.log(`‚ùå Server exited with code ${code}`);
    }
    process.exit(code);
  });

  child.on('error', (error) => {
    log.error(`Failed to start server: ${error.message}`);
    process.exit(1);
  });

  // Handle parent process signals
  process.on('SIGINT', () => {
    console.log('\nüõë Shutting down server...');
    child.kill('SIGINT');
  });

  process.on('SIGTERM', () => {
    console.log('\nüõë Shutting down server...');
    child.kill('SIGTERM');
  });

  return true;
}

async function runClean(projectRoot) {
  await cleanupProcesses(projectRoot, true);
}

async function runSetupDomains(projectRoot) {
  console.log('üåê Setting up custom domains...');
  
  const setupScript = path.join(projectRoot, 'scripts', 'setup-domains.sh');
  
  const child = spawn('bash', [setupScript], {
    stdio: 'inherit',
    cwd: projectRoot
  });

  return new Promise((resolve, reject) => {
    child.on('close', (code) => {
      if (code === 0) {
        console.log('‚úÖ Domain setup completed');
        resolve();
      } else {
        reject(new Error(`Domain setup failed with code ${code}`));
      }
    });
  });
}

async function checkStatus(projectRoot) {
  console.log('üìä Checking server status...');
  const net = require('net');
  const portsToCheck = [8080, 3001, 3002, 3003, 3004, 3005];

  for (const port of portsToCheck) {
    try {
      const server = net.createServer();
      const isPortFree = new Promise((resolve) => {
        server.listen(port, '127.0.0.1', () => {
          server.close();
          resolve(true);
        });
        server.on('error', () => resolve(false));
      });

      const free = await isPortFree;
      if (!free) {
        console.log(`üü¢ Port ${port} is in use`);
      } else {
        console.log(`‚ö™ Port ${port} is free`);
      }
    } catch (e) {
      console.log(`‚ùå Error checking port ${port}: ${e.message}`);
    }
  }
}

async function runDeploy(projectRoot, env = 'prod') {
  console.log(`üöÄ Starting ${env === 'dev' ? 'development' : 'production'} deployment...`);
  
  // Clean up any existing processes that might interfere
  try {
    console.log('üßπ Cleaning up existing processes...');
    const { execSync } = require("child_process");
    execSync(`pkill -f "scripts/d dev" || true`, { stdio: 'ignore' });
    execSync(`pkill -f "node.*index.js" || true`, { stdio: 'ignore' });
    // Wait a moment for processes to clean up
    await new Promise(resolve => setTimeout(resolve, 1000));
  } catch (error) {
    // Ignore cleanup errors
  }
  
  // Look for GCP deploy script
  const possibleDeployScripts = [
    path.join(projectRoot, 'scripts', 'deploy', 'deploy.sh'),
    path.join(projectRoot, 'scripts', 'deploy.sh')
  ];
  
  let deployScript = null;
  for (const script of possibleDeployScripts) {
    if (fs.existsSync(script)) {
      deployScript = script;
      break;
    }
  }
  
  if (!deployScript) {
    console.error('‚ùå GCP deploy script not found!');
    console.log('üí° Looked in these locations:');
    possibleDeployScripts.forEach(script => console.log(`   - ${script}`));
    console.log('üí° The ship command is configured for GCP deployment only');
    throw new Error('GCP deploy script not found');
  }
  
  console.log(`üìú Using deploy script: ${deployScript}`);

  // Run deploy script with explicit environment
  const child = spawn('bash', [deployScript, env], {
    stdio: 'inherit',
    cwd: projectRoot,
    env: {
      ...process.env,
      NODE_ENV: env === 'dev' ? 'development' : 'production',
      NODE_OPTIONS: ''
    }
  });

  return new Promise((resolve, reject) => {
    child.on('close', (code) => {
      if (code === 0) {
        console.log('‚úÖ Deployment completed successfully');
        resolve();
      } else {
        console.error(`‚ùå Deployment failed with exit code ${code}`);
        console.log('üí° Check the deploy script for errors');
        reject(new Error(`Deployment failed with code ${code}`));
      }
    });

    child.on('error', (error) => {
      console.error('‚ùå Failed to start deployment process:', error.message);
      console.log('üí° Make sure the deploy script has execute permissions: chmod +x deploy.sh');
      reject(error);
    });
  });
}

function setupAliases(projectRoot) {
  const scriptPath = path.join(projectRoot, 'scripts', 'd');
  
  // Output shell aliases that can be sourced
  console.log(`# Development aliases for ${path.basename(projectRoot)}`);
  console.log(`alias d='${scriptPath}'`);
  console.log(`alias ship='${scriptPath} deploy'`);
  console.log(`alias clean='${scriptPath} clean'`);
  console.log(`alias test='${scriptPath} test'`);
  console.log(`alias build='${scriptPath} build'`);
  console.log(`alias status='${scriptPath} status'`);
}

// Development server startup (original dev functionality)
async function runDevServer(projectRoot) {
  const entryPoint = findEntryPoint(projectRoot);

  if (!entryPoint) {
    console.error('‚ùå No entry point found');
    process.exit(1);
  }

  // Load config from PROJECT_ROOT/config/project.js
  const config = loadProjectConfig(projectRoot);

  // Set development mode - preserve existing NODE_OPTIONS
  process.env.NODE_ENV = 'development';

  // Check for existing server processes to avoid conflicts
  try {
    const { execSync } = require("child_process");
    const existingProcesses = execSync(`pgrep -f "node.*${path.basename(entryPoint)}" || true`, { encoding: 'utf8' });
    if (existingProcesses.trim()) {
      console.log('‚ö†Ô∏è Found existing server processes, they will be managed by the new instance');
    }
  } catch (e) {
    // Ignore process check errors
  }

  // Clean up ports (lightweight) and build frontend
  try {
    await cleanupProcesses(projectRoot, false); // Light cleanup
  } catch (error) {
    console.log('‚ö†Ô∏è Port cleanup failed:', error.message);
  }

  // Build frontend before starting server
  try {
    await runBuild(projectRoot);
  } catch (error) {
    console.log('‚ö†Ô∏è Frontend build failed:', error.message);
  }

  // Start server with loaded configuration
  console.log(`üìÅ Project: ${projectRoot}`);
  console.log(`üîß Initializing development server...\n`);

  // Simple browser opening function (production-like)
  const openBrowser = (url) => {
    const { exec } = require('child_process');
    try {
      if (process.platform === 'darwin') {
        // Open Chrome in incognito mode (no extensions)
        exec(`open -a "Google Chrome" "${url}" --args --incognito`, { stdio: 'ignore' });
      } else if (process.platform === 'win32') {
        exec(`start chrome "${url}" --incognito`, { shell: true, stdio: 'ignore' });
      } else {
        exec(`google-chrome "${url}" --incognito || xdg-open "${url}"`, { stdio: 'ignore' });
      }
      console.log('üåê Browser opened');
    } catch (err) {
      console.log('‚ö†Ô∏è Could not open browser automatically');
    }
  };

  const port = config ? config.env.PORT : 8080;
  const httpsPort = process.env.HTTPS_PORT || 3001;

  // Check for no-debug flag (default to true for cleaner output)
  const noDebug = !process.argv.includes('--debug');

  // Filter out debugger-related arguments and our custom flag
  const filteredArgs = process.argv.slice(2).filter(arg =>
    arg !== '--no-debug' &&
    arg !== '--debug' &&
    !arg.includes('--inspect') &&
    !arg.includes('VSCODE_INSPECTOR') &&
    !arg.includes('NODE_OPTIONS') &&
    !arg.startsWith('--require=') &&
    !arg.includes('bootloader.js')
  );

  // Start the server
  const spawnArgs = noDebug
    ? ['--no-deprecation', entryPoint, ...filteredArgs]
    : [entryPoint, ...filteredArgs];

  const spawnEnv = {
    ...process.env,
    // Disable debugger completely by default
    ...(noDebug && { 
      NODE_OPTIONS: '',
      NODE_INSPECT_RESUME_ON_START: '0',
      NODE_INSPECT: '0'
    })
  };

  // Remove any debugger-related environment variables
  if (noDebug) {
    delete spawnEnv.NODE_INSPECT;
    delete spawnEnv.NODE_INSPECT_RESUME_ON_START;
    delete spawnEnv.VSCODE_INSPECTOR_OPTIONS;
  }

  const child = spawn('node', spawnArgs, {
    stdio: ['inherit', 'pipe', 'pipe'], // Capture stdout and stderr to reduce noise
    cwd: projectRoot,
    env: spawnEnv,
    // Disable debugger detection
    detached: false
  });

  // Reduce debugger noise by buffering output
  let serverStarted = false;
  let outputBuffer = '';
  let fallbackTimeout;

  child.stdout?.on('data', (data) => {
    const output = data.toString();
    outputBuffer += output;

    // Look for server ready indicators - show clean startup
    if (!serverStarted && (output.includes('Server initialization started') || output.includes('HTTP server started'))) {
      serverStarted = true;
      if (fallbackTimeout) {
        clearTimeout(fallbackTimeout);
      }

      // Clear any previous output and show clean startup
      console.log('\nüöÄ Server started successfully!');
      console.log(`üì° HTTP:  http://localhost:${port}`);
      console.log(`üîê HTTPS: https://localhost:${httpsPort}`);
      console.log(`üì± LAN:   http://localhost:${port} (or your network IP)`);
      console.log('‚úÖ Ready to accept connections...\n');
      
      // Open browser automatically to HTTP server (more reliable)
      setTimeout(() => {
        const targetUrl = `http://localhost:${port}`;
        openBrowser(targetUrl);
      }, 1000); // Small delay to ensure server is fully ready
    }

    // Show important server initialization messages
    if (output.includes('Server initialization started') ||
        output.includes('PostgreSQL module loaded') ||
        output.includes('HTTPS server started') ||
        output.includes('Environment configuration loaded') ||
        output.includes('HTTP server started') ||
        output.includes('Server exited with code') ||
        output.includes('‚ùå Failed to start') ||
        output.includes('Error:') ||
        output.includes('SyntaxError')) {
      if (output.includes('Error:') || output.includes('SyntaxError') || output.includes('Server exited with code')) {
        console.log('‚ùå', output.trim());
      } else {
        console.log(output.trim());
      }
    }
  });

  child.stderr?.on('data', (data) => {
    const error = data.toString();
    // Comprehensive debugger noise suppression
    const debuggerMessages = [
      'Debugger listening',
      'Debugger attached',
      'Waiting for the debugger',
      'For help, see:',
      'ws://127.0.0.1:',
      'nodejs.org/en/docs/inspector',
      'Debugger ending on',
      'Waiting for the debugger to disconnect',
      'Debugger listening on ws://',
      'Debugger attached.',
      'For help, see: https://nodejs.org/en/docs/inspector'
    ];
    
    const isDebuggerNoise = debuggerMessages.some(msg => error.includes(msg)) || 
                           error.match(/ws:\/\/127\.0\.0\.1:\d+\/[a-f0-9-]+/) ||
                           error.includes('nodejs.org/en/docs/inspector');
    
    if (!isDebuggerNoise) {
      // Only show real errors that aren't part of normal startup
      if (error.includes('Error') || error.includes('failed') || error.includes('exception') || error.includes('ENOENT')) {
        console.log('‚ö†Ô∏è ', error.trim());
      }
    }
  });

  child.on('exit', (code) => {
    if (code === 0) {
      console.log('‚úÖ Server exited cleanly');
    } else if (code === null) {
      console.log('‚ö†Ô∏è Server process terminated (possibly due to debugger conflict)');
      console.log('üí° Try running with --no-debug flag if this persists');
    } else {
      console.log(`‚ùå Server exited with code ${code}`);
    }
    process.exit(code);
  });

  // Fallback: Show basic startup message if server detection fails
  fallbackTimeout = setTimeout(() => {
    if (!serverStarted) {
      console.log('\n‚è≥ Starting server...');
      console.log(`üì° Will be available at: http://localhost:${port}`);
      console.log(`üîê HTTPS at: https://localhost:${httpsPort}`);
    }
  }, 3000);

  child.on('error', (error) => {
    console.error('‚ùå Failed to start server:', error.message);
    console.log('üí° Try: d dev --no-debug');
    process.exit(1);
  });

  // Handle parent process signals
  process.on('SIGINT', () => {
    console.log('\nüõë Received SIGINT, shutting down server...');
    child.kill('SIGINT');
  });

  process.on('SIGTERM', () => {
    console.log('\nüõë Received SIGTERM, shutting down server...');
    child.kill('SIGTERM');
  });
}

// Find the main entry point
function findEntryPoint(projectRoot) {
  // First check package.json for main entry point
  try {
    const packagePath = path.join(projectRoot, 'package.json');
    if (fs.existsSync(packagePath)) {
      const pkg = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
      if (pkg.main) {
        const mainEntry = path.join(projectRoot, pkg.main);
        if (fs.existsSync(mainEntry)) {
          return mainEntry;
        }
      }
    }
  } catch (error) {
    // Ignore package.json parsing errors
  }

  // Check common entry points in project structure
  const possibleEntries = [
    'src/server/api/server.js',
    'src/server/index.js', 
    'backend/api/server.js',
    'backend/server.js',
    'server/index.js',
    'index.js', 
    'server.js', 
    'app.js', 
    'main.js'
  ];

  for (const entry of possibleEntries) {
    const entryPath = path.join(projectRoot, entry);
    if (fs.existsSync(entryPath)) {
      return entryPath;
    }
  }

  return null;
}

// Main execution - operation dispatcher
async function main() {
  const operation = process.argv[2] || 'dev';
  const projectRoot = findProjectRoot(process.cwd());

  // For non-dev operations, ensure we don't have debugger conflicts
  if (operation !== 'dev') {
    process.env.NODE_INSPECT = '0';
    // Don't set NODE_OPTIONS as it can cause issues with child processes
  }

  switch (operation) {
    case 'dev':
      // Default: deploy to dev.queb.space
      await runDeploy(projectRoot, 'dev');
      break;
    case 'prod':
      // Deploy to queb.space (production)
      await runDeploy(projectRoot, 'prod');
      break;
    case 'build':
      await runBuild(projectRoot);
      break;
    case 'test':
      await runTest(projectRoot);
      break;
    case 'validate':
      await runAppValidation(projectRoot);
      break;
    case 'health':
      await runAppHealthCheck(projectRoot);
      break;
    case 'auto':
      await runAutoValidateAndStart(projectRoot);
      break;
    case 'start':
      await runLocalDevServer(projectRoot);
      break;
    case 'clean':
      await runClean(projectRoot);
      break;
    case 'status':
      await checkStatus(projectRoot);
      break;
    case 'deploy':
      // Legacy: still works for production
      await runDeploy(projectRoot, 'prod');
      break;
    case 'setup-domains':
      await runSetupDomains(projectRoot);
      break;
    case 'setup-aliases':
      setupAliases(projectRoot);
      break;
    case 'help':
      showHelp();
      break;
    default:
      console.log(`‚ùå Unknown operation: ${operation}`);
      showHelp();
      process.exit(1);
  }
}

// Run the main function
main().catch((error) => {
  console.error('‚ùå Fatal error:', error);
  process.exit(1);
});

