#!/usr/bin/env node

const { spawn, execSync } = require('child_process');
const path = require('path');
const fs = require('fs');

const PROJECT_ROOT = path.resolve(__dirname, '..');

// Logging functions with emojis and colors
const colors = {
  red: '\033[0;31m',
  green: '\033[0;32m', 
  yellow: '\033[1;33m',
  blue: '\033[0;34m',
  magenta: '\033[0;35m',
  cyan: '\033[0;36m',
  gray: '\033[0;90m',
  nc: '\033[0m'
};

const log = {
  info: (msg) => console.log(`${colors.blue}â„¹ï¸  ${msg}${colors.nc}`),
  success: (msg) => console.log(`${colors.green}âœ… ${msg}${colors.nc}`),
  warning: (msg) => console.log(`${colors.yellow}âš ï¸  ${msg}${colors.nc}`),
  error: (msg) => console.log(`${colors.red}âŒ ${msg}${colors.nc}`),
  clean: (msg) => console.log(`${colors.yellow}ðŸ§¹ ${msg}${colors.nc}`),
  rocket: (msg) => console.log(`${colors.green}ðŸš€ ${msg}${colors.nc}`)
};

function setupAliases() {
  const os = require('os');
  const rcFile = process.env.SHELL?.includes('zsh') ? `${os.homedir()}/.zshrc` : `${os.homedir()}/.bashrc`;
  
  try {
    const content = fs.readFileSync(rcFile, 'utf8');
    if (!content.includes('# mol aliases start')) {
      execSync(`bash "${PROJECT_ROOT}/infrastructure/setup-aliases.sh"`, { stdio: 'ignore' });
    }
  } catch (err) {
    // Ignore setup errors
  }
}

async function generateCommitMessage() {
  const diff = execSync('git diff --cached --stat', { encoding: 'utf-8' });
  const detailedDiff = execSync('git diff --cached', { encoding: 'utf-8', maxBuffer: 1024 * 1024 });
  
  try {
    const openai = require('openai');
    const apiKey = process.env.OPENAI_API_KEY;
    
    if (apiKey) {
      const client = new openai.OpenAI({ apiKey });
      
      const prompt = `Generate a concise, semantic commit message for these changes:

Summary:
${diff}

First 500 chars of detailed changes:
${detailedDiff.substring(0, 500)}

Guidelines:
- Use conventional commit format (feat:, fix:, refactor:, docs:, style:, test:, chore:)
- Be specific but concise (max 72 chars)
- Focus on WHAT changed and WHY, not HOW
- Single line only`;

      const response = await client.chat.completions.create({
        model: process.env.OPENAI_COMMIT_MODEL || process.env.OPENAI_MODEL || process.env.OPENAI_DEFAULT_MODEL || 'gpt-4o-mini',
        messages: [{ role: 'user', content: prompt }],
        max_tokens: 100,
        temperature: 0.3
      });
      
      return response.choices[0].message.content.trim();
    }
  } catch (err) {
    log.info('OpenAI unavailable, using fallback...');
  }
  
  // Fallback: analyze diff to generate message
  const files = diff.split('\n').filter(line => line.includes('|'));
  const fileCount = files.length;
  
  if (fileCount === 0) return 'chore: minor updates';
  
  const changes = { feat: 0, fix: 0, test: 0, docs: 0, style: 0, refactor: 0, chore: 0 };
  
  files.forEach(file => {
    const filePath = file.split('|')[0].trim();
    if (filePath.includes('test/') || filePath.includes('.test.')) changes.test++;
    else if (filePath.includes('README') || filePath.includes('.md')) changes.docs++;
    else if (filePath.includes('.css') || filePath.includes('.scss')) changes.style++;
    else if (filePath.includes('package.json') || filePath.includes('config')) changes.chore++;
    else if (detailedDiff.includes('fix') || detailedDiff.includes('bug')) changes.fix++;
    else changes.feat++;
  });
  
  const primaryType = Object.entries(changes).reduce((a, b) => changes[a[0]] > changes[b[0]] ? a : b)[0];
  
  if (fileCount === 1) {
    const fileName = path.basename(files[0].split('|')[0].trim());
    return `${primaryType}: update ${fileName}`;
  } else {
    const areas = [...new Set(files.map(f => {
      const parts = f.split('|')[0].trim().split('/');
      return parts[0] === 'backend' || parts[0] === 'frontend' ? parts[0] : 'project';
    }))];
    
    return `${primaryType}: update ${areas.join(', ')} (${fileCount} files)`;
  }
}

function cleanupPorts() {
  log.clean('Cleaning up development: processes, ports, temp files, and test profiles');
  
  let totalKilled = 0;
  let portsFreed = 0;
  let filesRemoved = 0;
  let dirsRemoved = 0;

  const killPattern = (pattern, label) => {
    try {
      const pids = execSync(`pgrep -f "${pattern}"`, { encoding: 'utf8' }).trim();
      if (pids) {
        log.info(`ðŸ”ª ${label} (pattern: ${pattern}) PIDs: ${pids.replace(/\n/g, ' ')}`);
        execSync(`echo "${pids}" | xargs kill 2>/dev/null || true`, { shell: '/bin/bash' });
        execSync(`echo "${pids}" | xargs kill -9 2>/dev/null || true`, { shell: '/bin/bash' });
        totalKilled += pids.split('\n').length;
      } else {
        log.info(`âœ… No ${label} running`);
      }
    } catch (err) {
      log.info(`âœ… No ${label} running`);
    }
  };

  // Kill various process patterns
  killPattern('node.*backend/api/server.js', 'Node backend servers');
  killPattern('nodemon.*backend/api/server.js', 'Nodemon (backend)');
  killPattern('npm.*nodemon', 'npm-driven nodemon');
  killPattern('nodemon', 'Residual nodemon');
  killPattern('backend/api/server.js', 'Backend server scripts');
  killPattern('Google Chrome.*chrome-molecular-profile', 'Google Chrome (dev profiles)');
  killPattern('chrome.*chrome-molecular-profile', 'Chrome (dev profiles)');

  // Clean up PID files
  const pidFiles = ['/tmp/dev_watcher_pid', '/tmp/dev_browser_pid', '/tmp/dev_reload_pid', '/tmp/dev_backend_pid', '/tmp/dev_server_pid', '/tmp/frontend_last_check'];
  pidFiles.forEach(pidFile => {
    try {
      if (fs.existsSync(pidFile)) {
        const pid = fs.readFileSync(pidFile, 'utf8').trim();
        if (pid) {
          log.info(`ðŸ”ª Process PID: ${pid}`);
          try { process.kill(pid, 'SIGTERM'); } catch (e) {}
        }
        fs.unlinkSync(pidFile);
        filesRemoved++;
        log.info(`ðŸ—‘ï¸ Removed ${pidFile}`);
      }
    } catch (err) {
      // Ignore errors
    }
  });

  // Kill fswatch processes
  try {
    execSync('pkill -f "fswatch" 2>/dev/null || true');
  } catch (err) {}

  // Free up ports
  try {
    const ports = [3000, 3001, 3002, 3004, 9229, 9230, 9231];
    ports.forEach(port => {
      try {
        const pids = execSync(`lsof -ti:${port}`, { encoding: 'utf8' }).trim();
        if (pids) {
          log.info(`ðŸ§¹ Freeing port ${port} (PIDs: ${pids})`);
          execSync(`echo "${pids}" | xargs kill -9 2>/dev/null || true`, { shell: '/bin/bash' });
          portsFreed++;
        }
      } catch (err) {
        // Port not in use
      }
    });
  } catch (err) {
    // lsof not available
  }

  // Clean up temp directories
  const tempDirs = [
    path.join(PROJECT_ROOT, 'dist'),
    path.join(PROJECT_ROOT, 'frontend/dist'),
    path.join(PROJECT_ROOT, '.deploy-temp')
  ];
  
  tempDirs.forEach(dir => {
    try {
      if (fs.existsSync(dir)) {
        fs.rmSync(dir, { recursive: true, force: true });
        dirsRemoved++;
        log.info(`ðŸ—‘ï¸ Removed build dir: ${dir}`);
      }
    } catch (err) {}
  });

  // Clean test directories
  const testDir = path.join(PROJECT_ROOT, 'test');
  if (fs.existsSync(testDir)) {
    try {
      const entries = fs.readdirSync(testDir);
      entries.forEach(entry => {
        if (entry.startsWith('chrome-molecular-profile-') || 
            entry === 'seamless-chrome-profile' || 
            entry === 'single-tab-chrome') {
          const fullPath = path.join(testDir, entry);
          fs.rmSync(fullPath, { recursive: true, force: true });
          dirsRemoved++;
          log.info(`ðŸ—‘ï¸ Removed dir: ${fullPath}`);
        }
      });

      // Remove lock files
      const findLocks = (dir) => {
        try {
          const entries = fs.readdirSync(dir, { withFileTypes: true });
          entries.forEach(entry => {
            const fullPath = path.join(dir, entry.name);
            if (entry.isDirectory()) {
              findLocks(fullPath);
            } else if (entry.name === 'SingletonLock') {
              fs.unlinkSync(fullPath);
              filesRemoved++;
              log.info(`ðŸ—‘ï¸ Removed lock: ${fullPath}`);
            }
          });
        } catch (err) {}
      };
      findLocks(testDir);
    } catch (err) {}
  }

  setTimeout(() => {
    log.success(`Cleanup complete (stopped ${totalKilled} processes, freed ${portsFreed} ports, removed ${filesRemoved} files, ${dirsRemoved} dirs).`);
    log.success('You can now restart the server.');
  }, 1000);
}

function serve(args = []) {
  const debug = args.includes('--debug') || args.includes('-d');
  const nobrowser = args.includes('--no-browser') || args.includes('-B');

  setupAliases();
  cleanupPorts();

  log.rocket('Starting development environment...');
  
  const processes = [];

  // Frontend build watcher
  const feArgs = debug 
    ? ['--inspect=9230', path.join(PROJECT_ROOT, 'frontend/build-frontend.js'), '--watch']
    : [path.join(PROJECT_ROOT, 'frontend/build-frontend.js'), '--watch'];
  
  const frontend = spawn('node', feArgs, {
    env: { ...process.env, NODE_ENV: 'development' },
    stdio: 'inherit'
  });
  processes.push(frontend);

  // Backend with nodemon (integrated functionality)
  let nodemonInstance;
  try {
    const nodemon = require('nodemon');
    nodemonInstance = nodemon({
      script: path.join(PROJECT_ROOT, 'backend/api/server.js'),
      watch: [path.join(PROJECT_ROOT, 'backend')],
      ext: 'js json',
      ignore: [path.join(PROJECT_ROOT, 'frontend/**'), path.join(PROJECT_ROOT, 'test/**')],
      exec: 'node --inspect=9229',
      env: { ...process.env, PORT: '3000', NODE_ENV: 'development' },
      stdout: true,
      quiet: true
    });
    
    nodemonInstance.on('quit', () => {
      log.info('Backend stopped');
      process.exit(0);
    });
    
    nodemonInstance.on('restart', (files) => {
      log.info(`Backend restarted due to: ${files}`);
    });
  } catch (err) {
    log.error('nodemon not installed or failed to start (npm i -D nodemon)');
    process.exit(1);
  }

  // Dev browser (optional)
  if (!nobrowser) {
    const browserArgs = debug 
      ? ['--inspect=9231', path.join(PROJECT_ROOT, 'frontend/dev-browser.js')]
      : [path.join(PROJECT_ROOT, 'frontend/dev-browser.js')];
      
    const browser = spawn('node', browserArgs, {
      env: { ...process.env, FRONTEND_URL: 'http://localhost:3000' },
      stdio: 'inherit'
    });
    processes.push(browser);
  }

  // Cleanup handler
  const cleanup = () => {
    log.clean('Shutting down development environment...');
    
    // Stop nodemon
    if (nodemonInstance) {
      try { 
        nodemonInstance.emit('quit'); 
      } catch (e) {}
    }
    
    // Stop other processes
    processes.forEach(p => {
      try { p.kill('SIGTERM'); } catch (e) {}
    });
    
    setTimeout(() => {
      processes.forEach(p => {
        try { p.kill('SIGKILL'); } catch (e) {}
      });
      process.exit(0);
    }, 2000);
  };

  process.on('SIGINT', cleanup);
  process.on('SIGTERM', cleanup);
  process.on('exit', cleanup);
}

function build(args = []) {
  try {
    const buildScript = path.join(PROJECT_ROOT, 'frontend/build-frontend.js');
    if (!fs.existsSync(buildScript)) {
      log.error('Build script not found');
      process.exit(1);
    }
    
    const buildArgs = [buildScript, ...args.filter(arg => arg.match(/^--?[a-zA-Z]/))];
    execSync(`node ${buildArgs.map(arg => `"${arg}"`).join(' ')}`, { 
      stdio: 'inherit',
      cwd: PROJECT_ROOT
    });
  } catch (err) {
    log.error(`Build failed: ${err.message}`);
    process.exit(1);
  }
}

function test(args = []) {
  const testType = args[0] || 'all';
  const validTestTypes = ['unit', 'integration', 'system', 'watch', 'pytest', 'all'];
  
  if (!validTestTypes.includes(testType)) {
    log.error(`Invalid test type: ${testType}. Valid types: ${validTestTypes.join(', ')}`);
    process.exit(1);
  }
  
  const testCommands = {
    unit: ['npx', 'jest', '--testPathPattern=unit.test.js', '--verbose', '--silent'],
    integration: ['npx', 'jest', '--testPathPattern=integration.test.js', '--verbose'],
    system: ['npx', 'jest', '--testPathPattern=system.test.js', '--verbose', '--detectOpenHandles'],
    watch: ['npx', 'jest', '--watch'],
    pytest: ['python', '-m', 'pytest', 'testing/', '-v']
  };
  
  try {
    if (testType === 'all') {
      // Run tests sequentially for better error reporting
      const testSequence = ['unit', 'integration', 'system'];
      for (const type of testSequence) {
        log.info(`Running ${type} tests...`);
        execSync(testCommands[type].join(' '), { stdio: 'inherit', cwd: PROJECT_ROOT });
      }
    } else {
      const cmd = testCommands[testType];
      execSync(cmd.join(' '), { stdio: 'inherit', cwd: PROJECT_ROOT });
    }
    
    log.success(`${testType} tests completed`);
  } catch (err) {
    log.error(`${testType} tests failed`);
    process.exit(1);
  }
}

function clean(args = []) {
  cleanupPorts();
}

async function commit(args = []) {
  const messageFlag = args.indexOf('-m');
  let message = null;
  
  if (messageFlag !== -1 && args[messageFlag + 1]) {
    message = args.slice(messageFlag + 1).join(' ').replace(/"/g, '\\"');
  }

  try {
    // Check if we're in a git repository
    try {
      execSync('git rev-parse --git-dir', { stdio: 'pipe', cwd: PROJECT_ROOT });
    } catch (err) {
      log.error('Not in a git repository');
      process.exit(1);
    }

    // Check if there are changes
    const status = execSync('git status --porcelain', { encoding: 'utf8', cwd: PROJECT_ROOT });
    if (!status.trim()) {
      log.info('No changes to commit');
      return;
    }

    // Add all changes
    execSync('git add .', { stdio: 'inherit', cwd: PROJECT_ROOT });

    // Use provided message or generate one
    if (!message) {
      try {
        message = await generateCommitMessage();
        if (!message || message.length > 72) {
          message = 'chore: update files';
        }
      } catch (err) {
        log.warning('Failed to generate commit message, using fallback');
        message = 'chore: update files';
      }
    }

    console.log('ðŸ“‹ Changes to commit:');
    execSync('git status --short', { stdio: 'inherit', cwd: PROJECT_ROOT });
    console.log(`ðŸ“ Message: ${message}`);

    // Interactive confirmation
    const readline = require('readline');
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    const commitAndPush = (commitMessage) => {
      try {
        execSync('git commit -m ' + JSON.stringify(commitMessage), { stdio: 'inherit', cwd: PROJECT_ROOT });
        execSync('git push', { stdio: 'inherit', cwd: PROJECT_ROOT });
        log.success('Changes committed and pushed');
      } catch (err) {
        log.error(`Git operation failed: ${err.message}`);
        process.exit(1);
      }
    };

    rl.question('Proceed with commit and push? (y/n/e to edit message): ', (answer) => {
      if (answer.toLowerCase() === 'y') {
        commitAndPush(message);
        rl.close();
      } else if (answer.toLowerCase() === 'e') {
        rl.question('Enter commit message: ', (customMessage) => {
          if (customMessage.trim()) {
            commitAndPush(customMessage.trim());
          } else {
            log.warning('Empty message, using original');
            commitAndPush(message);
          }
          rl.close();
        });
      } else {
        execSync('git reset HEAD', { stdio: 'inherit', cwd: PROJECT_ROOT });
        log.info('Commit cancelled');
        rl.close();
      }
    });
  } catch (err) {
    log.error(`Commit failed: ${err.message}`);
    process.exit(1);
  }
}

function deploy(args = []) {
  const force = args.includes('--force');
  const skipTests = args.includes('--skip-tests');

  console.log('ðŸš€ Deploying to queb.space');

  // Check environment
  const envPath = path.join(PROJECT_ROOT, '.env');
  if (!fs.existsSync(envPath)) {
    console.error('âŒ .env file not found');
    process.exit(1);
  }

  const envContent = fs.readFileSync(envPath, 'utf8');
  const apiKeyMatch = envContent.match(/^OPENAI_API_KEY=(.+)$/m);
  if (!apiKeyMatch) {
    console.error('âŒ OPENAI_API_KEY not set in .env file');
    process.exit(1);
  }
  const apiKey = apiKeyMatch[1].replace(/['"]/g, '');

  try {
    // Check gcloud
    execSync('gcloud auth list --filter=status:ACTIVE --format="value(account)"', { stdio: 'pipe' });
  } catch (err) {
    console.error('âŒ Not authenticated with gcloud - run: gcloud auth login');
    process.exit(1);
  }

  // Run tests
  if (!skipTests) {
    try {
      test(['all']);
      console.log('âœ… Tests passed');
    } catch (err) {
      console.error('âŒ Tests failed');
      if (!force) {
        console.log('Use --skip-tests or --force to proceed anyway');
        process.exit(1);
      }
    }
  }

  // Build frontend
  build();

  // Deploy to Google Cloud Functions
  try {
    execSync(`gcloud functions deploy molecular-analysis \\
      --runtime nodejs20 \\
      --trigger-http \\
      --allow-unauthenticated \\
      --memory 1GB \\
      --timeout 540s \\
      --region us-central1 \\
      --entry-point molecularAnalysis \\
      --source . \\
      --max-instances 10 \\
      --set-env-vars "OPENAI_API_KEY=${apiKey},NODE_ENV=production,FUNCTION_NAME=molecular-analysis,FUNCTION_TARGET=molecularAnalysis"`, 
      { stdio: 'inherit', cwd: PROJECT_ROOT });

    console.log('');
    console.log('âœ… Deployment successful!');
    
    // Test deployment
    console.log('ðŸ§ª Testing deployment...');
    try {
      execSync('curl -sf "https://us-central1-mol-analysis-app.cloudfunctions.net/molecular-analysis/health"', { stdio: 'pipe' });
      console.log('âœ… Health check passed');
    } catch (err) {
      console.log('âš ï¸ Health check failed');
    }
    
    // Test domain
    try {
      execSync('curl -sf "https://queb.space/health"', { stdio: 'pipe' });
      console.log('âœ… Domain working');
    } catch (err) {
      console.log('âš ï¸ Domain may need time to propagate');
    }
    
    console.log('');
    console.log('ðŸŒ Your app is now live at:');
    console.log('   âœ… https://queb.space');
    console.log('   âœ… https://www.queb.space');
    console.log('');
    console.log('ðŸ”— Try these endpoints:');
    console.log('   - https://queb.space/ (Full App)');
    console.log('   - https://queb.space/health (API status)');
    console.log('');
    console.log('ðŸ”§ Cloud console: https://console.cloud.google.com/functions/list');
  } catch (err) {
    console.log('');
    console.log('âŒ Deployment failed');
    console.log('');
    console.log('ðŸ’¡ Troubleshooting tips:');
    console.log('   1. Check the error logs above');
    console.log('   2. Verify your .env file has OPENAI_API_KEY');
    console.log('   3. Try: dev deploy --skip-tests --force');
    console.log('   4. Check site manually: https://queb.space');
    process.exit(1);
  }
}

function status(args = []) {
  console.log('ðŸ” Queb.Space Status Check');
  console.log('=========================');
  console.log('');

  // Check local development environment
  console.log('ðŸ  Local Development (localhost)');
  console.log('-------------------------------');

  // Check .env file
  if (fs.existsSync(path.join(PROJECT_ROOT, '.env'))) {
    log.success('.env file exists');
  } else {
    log.error('.env file missing');
  }

  // Check SSL certificates
  const certPath = path.join(PROJECT_ROOT, 'backend/api/certs/cert.pem');
  const keyPath = path.join(PROJECT_ROOT, 'backend/api/certs/key.pem');
  if (fs.existsSync(certPath) && fs.existsSync(keyPath)) {
    log.success('SSL certificates exist');
  } else {
    log.error('SSL certificates missing');
  }

  log.success('Using localhost (no hosts entry needed)');

  // Check Node.js server
  try {
    execSync('pgrep -f "node.*server.js"', { stdio: 'pipe' });
    log.success('Node.js server is running');
  } catch (err) {
    log.warning('Node.js server is not running');
  }

  console.log('DNS: localhost always resolves');
  console.log('');

  // Check Google Cloud environment
  console.log('â˜ï¸ Google Cloud (queb.space)');
  console.log('---------------------------');

  // Check if gcloud is installed
  try {
    execSync('command -v gcloud', { stdio: 'pipe' });
    log.success('gcloud CLI installed');
  } catch (err) {
    log.error('gcloud CLI not installed');
    console.log('');
    console.log('ðŸ“‹ Local Development Status Summary:');
    console.log('   Run: ./setup-queb-space.sh (option 1)');
    console.log('   Start: ./dev-queb-space');
    return;
  }

  // Check authentication
  try {
    const activeAccount = execSync('gcloud auth list --filter=status:ACTIVE --format="value(account)"', { encoding: 'utf8' }).trim();
    if (activeAccount) {
      log.success('Google Cloud authenticated');
      console.log(`   ${activeAccount}`);
    } else {
      log.error('Google Cloud not authenticated');
    }
  } catch (err) {
    log.error('Google Cloud not authenticated');
  }

  // Check project
  try {
    const currentProject = execSync('gcloud config get-value project', { encoding: 'utf8' }).trim();
    if (currentProject === 'molecular-analysis') {
      log.success('Project set to molecular-analysis');
    } else {
      log.warning(`Project set to: ${currentProject}`);
    }
  } catch (err) {
    log.warning('No project configured');
  }

  // Check DNS zone
  try {
    execSync('gcloud dns managed-zones describe queb-space-zone --format="value(name)"', { stdio: 'pipe' });
    log.success('DNS zone exists');
    
    const nameservers = execSync('gcloud dns managed-zones describe queb-space-zone --format="value(nameServers)"', { encoding: 'utf8' }).trim();
    console.log('   Nameservers:');
    nameservers.split(';').forEach(ns => console.log(`     ${ns}`));
  } catch (err) {
    log.error('DNS zone missing');
  }

  // Check Cloud Function
  try {
    const functionStatus = execSync('gcloud functions describe molecular-analysis --region=us-central1 --format="value(status)"', { encoding: 'utf8' }).trim();
    if (functionStatus === 'ACTIVE') {
      log.success('Cloud Function is ACTIVE');
      
      try {
        const functionUrl = execSync('gcloud functions describe molecular-analysis --region=us-central1 --format="value(serviceConfig.uri)"', { encoding: 'utf8' }).trim();
        console.log(`   Function URL: ${functionUrl}`);
        
        // Test function
        try {
          execSync(`curl -s -f "${functionUrl}"`, { stdio: 'pipe' });
          log.success('Function responds to requests');
        } catch (err) {
          log.warning('Function does not respond to requests');
        }
      } catch (err) {}
    } else {
      log.warning(`Cloud Function status: ${functionStatus}`);
    }
  } catch (err) {
    log.error('Cloud Function not found');
  }

  // Check domain mappings
  console.log('');
  console.log('ðŸ”— Domain Mappings:');

  const checkMapping = (domain) => {
    try {
      const mappingStatus = execSync(`gcloud beta run domain-mappings describe --service=molecular-analysis --domain=${domain} --region=us-central1 --format="value(status)"`, { encoding: 'utf8' }).trim();
      if (mappingStatus === 'ACTIVE') {
        log.success(`${domain} mapping: ACTIVE`);
      } else {
        log.warning(`${domain} mapping: ${mappingStatus}`);
      }
    } catch (err) {
      log.error(`${domain} mapping: Not found`);
    }
  };

  checkMapping('queb.space');
  checkMapping('www.queb.space');

  // Test domain resolution  
  console.log('');
  console.log('ðŸŒ Domain Resolution:');

  const testDomain = (domain) => {
    try {
      execSync(`nslookup ${domain}`, { stdio: 'pipe' });
      log.success(`${domain} resolves`);
    } catch (err) {
      log.warning(`${domain} does not resolve`);
    }
  };

  testDomain('queb.space');
  testDomain('www.queb.space');

  console.log('');
  console.log('ðŸ“‹ Summary:');
  console.log('===========');

  // Local development summary
  const hasEnv = fs.existsSync(path.join(PROJECT_ROOT, '.env'));
  const hasCerts = fs.existsSync(path.join(PROJECT_ROOT, 'backend/api/certs/cert.pem'));
  
  if (hasEnv && hasCerts) {
    log.success('Local development ready');
    console.log('   Start: ./dev-queb-space');
  } else {
    log.warning('Local development needs setup');
    console.log('   Setup: ./setup-queb-space.sh (option 1)');
  }

  // Production summary
  try {
    execSync('command -v gcloud', { stdio: 'pipe' });
    const activeAccount = execSync('gcloud auth list --filter=status:ACTIVE --format="value(account)"', { encoding: 'utf8' }).trim();
    const functionStatus = execSync('gcloud functions describe molecular-analysis --region=us-central1 --format="value(status)"', { encoding: 'utf8' }).trim();
    
    if (activeAccount && functionStatus === 'ACTIVE') {
      log.success('Production ready');
      console.log('   Deploy: ./deploy-queb-space');
    } else {
      log.warning('Production needs setup');
      console.log('   Setup: ./setup-queb-space.sh (option 2 or 3)');
    }
  } catch (err) {
    log.warning('Production needs setup');
    console.log('   Setup: ./setup-queb-space.sh (option 2 or 3)');
  }
}

function showHelp() {
  console.log('Usage: dev [command] [options]');
  console.log('');
  console.log('Commands:');
  console.log('  serve (default)    Start development environment');
  console.log('  build             Build frontend');
  console.log('  test              Run tests');
  console.log('  clean             Clean up processes and temp files');
  console.log('  commit            Commit and push changes');
  console.log('  deploy|ship       Deploy to production');
  console.log('  status            Check environment status');
  console.log('  alias             Setup shell aliases');
  console.log('');
  console.log('Options for serve:');
  console.log('  -d, --debug       Enable debug mode');
  console.log('  -B, --no-browser  Skip opening browser');
  console.log('');
  console.log('Options for test:');
  console.log('  unit              Run unit tests');
  console.log('  integration       Run integration tests');
  console.log('  system            Run system tests');
  console.log('  watch             Run tests in watch mode');
  console.log('  pytest            Run Python tests');
  console.log('  all (default)     Run all test types');
  console.log('');
  console.log('Options for deploy:');
  console.log('  --force           Deploy even if health checks fail');
  console.log('  --skip-tests      Skip running tests before deployment');
  console.log('');
  console.log('Options for commit:');
  console.log('  -m "message"      Use specific commit message');
}

// Parse command
const [cmd = 'serve', ...args] = process.argv.slice(2);

(async () => {
  switch (cmd) {
    case 'serve':
    case 's':
      serve(args);
      break;
    case 'build':
    case 'b':
      build(args);
      break;
    case 'test':
    case 't':
      test(args);
      break;
    case 'clean':
      clean(args);
      break;
    case 'commit':
    case 'c':
      await commit(args);
      break;
    case 'deploy':
    case 'ship':
      deploy(args);
      break;
    case 'status':
      status(args);
      break;
    case 'alias':
      setupAliases();
      log.success('Aliases setup complete. Restart your shell.');
      break;
    case '--help':
    case '-h':
    case 'help':
      showHelp();
      break;
    default:
      serve([cmd, ...args]);
  }
})();